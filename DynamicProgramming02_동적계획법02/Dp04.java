package DynamicProgramming02_동적계획법02;

// 날짜 : 2022/11/2
// 문제 : 증가했다가 감소하는 부분 수열
// 문제 설명 :
// N개의 숫자가 주어졌을 때, 가장 긴 증가-감소 부분 수열의 길이를 구하는 프로그램을 작성해보세요.
// 부분 수열이란 수열의 원소들 중 임의로 몇 개를 골라 순서대로 나열한 수열을 의미합니다.
// 증가-감소 부분수열은 순서대로 나열했을 때 원소들이 계속 증가하다가 특정 순간부터는 계속 감소하기 시작하는 수열을 증가-감소 부분 수열이라고 합니다. 단, 처음부터 끝까지 계속 증가만 하거나 계속 감소만 하는 부분수열 역시 증가-감소 부분수열임에 유의합니다.
// 예를 들어, N=7, 주어진 수열이 1,4,2,5,6,2,1 이라 했을 때
// 2,4,5,2는 순서대로 나열해 만들 수 없으므로 부분 수열이라 할 수 없습니다.
// 1,4,2,5는 부분 수열 이지만 증가, 감소 후 다시 값이 증가하였기에 증가-감소 부분 수열이 아닙니다.
// 1,4,5는 부분 수열이고 증가만 일어났기에 증가-감소 부분 수열입니다.
// 4,2는 부분 수열이고 감소만 일어났기에 증가-감소 부분 수열입니다.
// 1,2,5,6,2,1은 계속 증가하다가 6에서부터 계속 감소만 하기에 증가-감소 부분 수열 입니다.


// 입력 형식 :
// 첫째 줄에는 N이 주어집니다.
// 두 번째 줄에는 N개의 숫자가 공백을 사이에 두고 주어집니다.
// 1≤N≤1,000
// 1≤ 수열의 원소 (M)≤10,000

// 입력 예시 01 :
// 7
// 1 4 2 5 6 2 1

// 출력 예시 01 :
// 6
// 6 5 4 3 4 5

// dp[i][0] : 해당 i 지점까지 증가만 하는 부분 수열의 최대 길이
// dp[i][1] : 해당 i 지점까지 감소만 하는 부분 수열의 최대 길이
// dp
import java.util.Arrays;
import java.util.Scanner;

public class Dp04 {

    public static final int MAX_N = 1000;

    public static int n;
    public static int[] arr = new int[MAX_N + 1];
    public static int[][] dp = new int[MAX_N + 1][MAX_N + 1];

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();

        for (int i = 1; i <= n ; i++) {
            arr[i] = sc.nextInt();
        }


        for (int i = 1; i <= n ; i++) {

            dp[i][0] = 1;
            dp[i][1] = 1;
            // i 이전 지점 (j) 를 모두 탐색하여
            // dp[i][0], dp[i][1] 의 값을 업데이트
            // dp[i][0] = 증가하는 방향으로 해당 지점까지 가능한 최대 증가 부분 수열의 길이
            // dp[i][1] = 감소하는 방향으로 해당 지점까지 가능한 최대 감소 부분 수열의 길이

            for (int j = 1; j < i ; j++) {

                if(arr[i] > arr[j]) // 증가하는 방향
                    dp[i][0] = Math.max(dp[i][0], dp[j][0]);

                if(arr[i] < arr[j]) // 감소하는 방향
                    dp[i][1] = Math.max(dp[i][1], dp[j][1]);
            } // for 문 후에는 각 인덱스에 해당 정점까지의 증가하는 방향일 때 최대 길이, 감소하는 방향일 때 최소 길이값이 업데이트 된 상태

            // 임의의 i 지점에서 다시 감소하는 방향으로 가는 것을 고려해야함
            // 결국 증가 - 감소 , 계속 증가 , 계속 감소 중 최대값만 구하면 됨
            dp[i][1] = Math.max(dp[i][1], dp[i][0]);

            // ex> 1, 4, 2, 5, 6, 2, 1, 7 ( 값이 7인 지점을 고려해보자)
        }

        int ans = 0;
        for (int i = 1; i <= n ; i++) {
            for (int j =1 ; j <= n ; j++) {
                ans = Math.max(ans, dp[i][j]);
            }
        }

        System.out.println(ans);

    }
}

